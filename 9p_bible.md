# The Nine Panels Bible üôè

Notes, coding, style guide, architecture notes.

## Code Styling:

`print()` must not make it to production. search for that in staging before deployment.
`console.log()` must not make it to production. search for that in staging before deployment.

### imports

#### order
import order should be roughly:

- full stdlib packages
- site packages grouped by package
- ninepanels imports

#### form

imports from ninepanels itself should generally be explicit and in full:

```from . import crud```

not:

``` from .crud import create_user```

This helps see in the code which file is providing the function. Exceptions to this rule for Depends(get_db) etc are ok.

any classes or funcs imported should be one per line only:

```
from sqlalchemy.orm import Column
from sqlalchemy.orm import Integer
```

not:

```
from sqlalchemy.orm import Integer, Column
```

This helps maintain visual clarity.

#### naming

```
from . import sqlmodels as sql
from . import pydmodels as pyd
```

### time data

Use utc times for all system related times such as logs.

```timestamp=datetime.utcnow()
```

## Exception Handling:

All exceptions defined in the code must be of a custom type and inherit from `NinePanelsBaseException`.

`NinePanelsBaseException` handles all error logging, and ensures all errors contain a `detail` property.

`detail` is the human readbale, user friendly error message. `context_msg` provides space for a more technical description. `context_data` kwargs accept key value pairs of data relevant to the error.

At the main.py api level, all customer errors propgated up must be then wrapped finally in a `fastapi.HTTPException` with the `detail` param passed from the custom exception:

```
try:
    resp = update_foo()
except exceptions.FooNotUpdated as e:
    raise HTTPException(status=400, detail=e.detail)
```

## API Design:

### Wrapped Responses

All responses, apart from those listed below, are intercepted by a middleware `ResponseWrapperMiddleware` that wraps the response in a standard object `.pydmodels.WrappedResponse`

Exceptions to wrapped responses:

- /docs
- /openapi.json
- /redoc

`/token` is not wrapped if the calling referer is `/docs` so as to enable swagger docs to authenticate.

## Logging and Monitoring:

Log messages are of a standard schema defined in `.pydmodels.LogMessage`. All calls to `logging` shoudl utilise the LogMessage schema.

Timing and performance monitoring uses a `Monitor` instance. Monitor instances have a `name` param on instantiation and simple `start` and `stop` methods. They have a `report` method which returns their current state.

Monitor instances are generated by a `MonitorFactory` which ensures only one instance of a monitor for a given `name` can exist and enables reporting on all monitor instances in memory by calling `report_all`. `MonitorFactory` is instantiated in `.config` and then can be imported to any file needing timing.

General request response timing is provided by a custom middleware instance called `TimingMiddleware`. Monitor instances can also be placed in an ad hoc manner anywhere needed (db calls etc) and will appear in the parent `MonitorFactory` `report_all` method.

## Testing:

## Environment Management:

Three branch strategy: Feature, Staging, Main (production)

`mc.sh` is a set of orchestration and guardrails written in shell (`mc.sh` and it's children) and python (`data_mgmt.py`) to manage data in feature, staging and prod envs

## Deployment

Keep commits atomic and more better than less, push to prod often with small changes. Easier to fix forward

**ALWAYS FIX FORWARD if needed**

Do not rollback, revert or otherwise fuck with the branch timelines.

Follow the deployment checklist for pushes from staging to prod.

initial questions to ask:

- does this involve a db schema migration?
- does this involve deploying front and backends in tandem?

**CHECKLIST:**
- update backup table selection across backup.sh if db schema changes
- search for prints and console.logs - verify 0
- check any helpers like temp component log in state for example are reset
- check any new envars are in staging and prod
- review each change before commit
- manual testing of area in feature env
- push to staging and manually test
- local tests pass on feature branch
- PR staging to main and review code changes again in GH
- backup main db full and data only
- merge PR
- manually test in prod



## Documentation:

### API Docs

Published doc style will be redoc.